<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"
    integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

<html>

<head>

    <title>D3</title>

    <script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
	<link rel="stylesheet" type="text/css" href="{{url_for('static', filename='css/style.css') }}">

	<script src="{{url_for('static', filename='scripts/script.js') }}"></script>
	<script src="https://d3js.org/d3.v5.min.js"></script>	

</head>

<body>

<div id="success"><h2>Assignment 01</h2></div>
<div id="chart"></div>
	
	<svg width="1080" height="1080">
	</svg>
    <script type="text/javascript">
	
		$(document).ready(function()
		{
			$.ajax({
				//Get all the countries from the countries page.
				url: "http://10.25.138.109/countries",
				//force to handle it as text
				dataType: "text",
				success: function(data) {

					//data downloaded so we call parseJSON function 
					//and pass downloaded data
					var json = $.parseJSON(data);
					
					
					
					
					// Various accessors that specify the four dimensions of data to visualize.
					function x(d) { return d.income; }
					function y(d) { return d.lifeExpectancy; }
					function radius(d) { return d.population; }
					function color(d) { return d.region; }
					function key(d) { return d.name; }

					// Chart dimensions.
					var margin = {top: 10, right: 30, bottom: 40, left: 60};
					var tileSize = d3.select("#chart")
					  .node()
					  .getBoundingClientRect();
					  width = tileSize.width - margin.left - margin.right;
					  height = tileSize.height - margin.top - margin.bottom;

					// Various scales. These domains make assumptions of data, naturally.
					/*var xScale = d3.scale.log().domain([300, 1e5]).range([0, width]),
						yScale = d3.scale.linear().domain([10, 85]).range([height, 0]),
						radiusScale = d3.scale.sqrt().domain([0, 5e8]).range([0, 40]),
						colorScale = d3.scale.category10();*/

					// The x & y axes.
					/*var xAxis = d3.svg.axis().orient("bottom").scale(xScale).ticks(12, d3.format(",d")),
						yAxis = d3.svg.axis().scale(yScale).orient("left");*/

					// Create the SVG container and set the origin.
					var svg = d3.select("#chart").append("svg")
						.attr("width", width + margin.left + margin.right)
						.attr("height", height + margin.top + margin.bottom)
					  .append("g")
						.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

					// Add the x-axis.
					svg.append("g")
						.attr("class", "x axis")
						.attr("transform", "translate(0," + height + ")")
						.call(xAxis);

					// Add the y-axis.
					svg.append("g")
						.attr("class", "y axis")
						.call(yAxis);

					// Add an x-axis label.
					svg.append("text")
						.attr("class", "x label")
						.attr("text-anchor", "end")
						.attr("x", width)
						.attr("y", height - 6)
						.text("income per capita, inflation-adjusted (dollars)");

					// Add a y-axis label.
					svg.append("text")
						.attr("class", "y label")
						.attr("text-anchor", "end")
						.attr("y", 6)
						.attr("dy", ".75em")
						.attr("transform", "rotate(-90)")
						.text("life expectancy (years)");

					// Add the year label; the value is set on transition.
					var label = svg.append("text")
						.attr("class", "year label")
						.attr("text-anchor", "end")
						.attr("y", height - 24)
						.attr("x", width)
						.text(1800);

					// Load the data.
					d3.json("https://bost.ocks.org/mike/nations/nations.json", function(nations) {

					  // A bisector since many nation's data is sparsely-defined.
					  var bisect = d3.bisector(function(d) { return d[0]; });

					  // Add a dot per nation. Initialize the data at 1800, and set the colors.
					  var dot = svg.append("g")
						  .attr("class", "dots")
						.selectAll(".dot")
						  .data(interpolateData(1800))
						.enter().append("circle")
						  .attr("class", "dot")
						  .style("fill", function(d) { return colorScale(color(d)); })
						  .call(position)
						  .sort(order);

					  // Add a title.
					  dot.append("title")
						  .text(function(d) { return d.name; });

					  // Add an overlay for the year label.
					  var box = label.node().getBBox();

					  var overlay = svg.append("rect")
							.attr("class", "overlay")
							.attr("x", box.x)
							.attr("y", box.y)
							.attr("width", box.width)
							.attr("height", box.height)
							.on("mouseover", enableInteraction);

					  // Start a transition that interpolates the data based on year.
					  svg.transition()
						  .duration(30000)
						  .ease("linear")
						  .tween("year", tweenYear)
						  .each("end", enableInteraction);

					  // Positions the dots based on data.
					  function position(dot) {
						dot .attr("cx", function(d) { return xScale(x(d)); })
							.attr("cy", function(d) { return yScale(y(d)); })
							.attr("r", function(d) { return radiusScale(radius(d)); });
					  }

					  // Defines a sort order so that the smallest dots are drawn on top.
					  function order(a, b) {
						return radius(b) - radius(a);
					  }

					  // After the transition finishes, you can mouseover to change the year.
					  function enableInteraction() {
						var yearScale = d3.scale.linear()
							.domain([1800, 2009])
							.range([box.x + 10, box.x + box.width - 10])
							.clamp(true);

						// Cancel the current transition, if any.
						svg.transition().duration(0);

						overlay
							.on("mouseover", mouseover)
							.on("mouseout", mouseout)
							.on("mousemove", mousemove)
							.on("touchmove", mousemove);

						function mouseover() {
						  label.classed("active", true);
						}

						function mouseout() {
						  label.classed("active", false);
						}

						function mousemove() {
						  displayYear(yearScale.invert(d3.mouse(this)[0]));
						}
					  }

					  // Tweens the entire chart by first tweening the year, and then the data.
					  // For the interpolated data, the dots and label are redrawn.
					  function tweenYear() {
						var year = d3.interpolateNumber(1800, 2009);
						return function(t) { displayYear(year(t)); };
					  }

					  // Updates the display to show the specified year.
					  function displayYear(year) {
						dot.data(interpolateData(year), key).call(position).sort(order);
						label.text(Math.round(year));
					  }

					  // Interpolates the dataset for the given (fractional) year.
					  function interpolateData(year) {
						return nations.map(function(d) {
						  return {
							name: d.name,
							region: d.region,
							income: interpolateValues(d.income, year),
							population: interpolateValues(d.population, year),
							lifeExpectancy: interpolateValues(d.lifeExpectancy, year)
						  };
						});
					  }

					  // Finds (and possibly interpolates) the value for the specified year.
					  function interpolateValues(values, year) {
						var i = bisect.left(values, year, 0, values.length - 1),
							a = values[i];
						if (i > 0) {
						  var b = values[i - 1],
							  t = (year - a[0]) / (b[0] - a[0]);
						  return a[1] * (1 - t) + b[1] * t;
						}
						return a[1];
					  }
					});
					
					
					
					/*
					var g = d3.select("svg").selectAll("g").data(json);
		
					var en = g.enter().append("g")
						.attr("transform",function(d){
						return "translate("+ (Math.random() * 900) + 40 + "," + (Math.random() * 900) + 40 +")" 
					})
					.on("mouseover", function(){return tooltip.style("visibility", "visible");})
					.on("mouseout", function(){return tooltip.style("visibility", "hidden");});
					//.on('mouseover', tooltip.show)
					//.on('mouseout', tooltip.hide);
					//.on("mouseover", en.append("text").text(function(d){ return d.name }))
					//.on("mouseout", en.append("text").text(""));
					
					var circle = en.append("circle")
						//.data(d => d.name)
						.attr("r",function(d){ return Math.random() * 20 + 10})
						.attr("fill",function(d,i){ return i % 2 == 0 ? "red" : "blue" });
						
						
						
					
					var tooltip = d3.select("body")
						.selectAll("svg")
						.data(data)
						.style("position", "absolute")
						.enter().append("div")
						//.style("width", function(d) { return x(d) + "px"; })
						.style("visibility", "hidden")
						.text(function(d) { return d.name; });
						//.style("z-index", "10")
						
						//.text("a simple tooltip")
						//.tyme()
						//.append(tyme);
						//.text(function(d){ return d.name });
						
						
					//var tyme = return d.name;
						/*
					var path = d3.selectAll('path')
						.enter()
						.append('path')
						.on('mouseover', function (d, i) {
							d3.select(this).transition()
								.duration('50')
								.attr('opacity', '.85')
								.append("text").text(function(d){ return d.name })});*/
					
					//en.append("text").text(function(d){ return d.name });	*/			
				
				}
			});		
		
		
		//Extra code - For reference
		/*
			$.ajax({
			  type: 'GET',
			  url: 'http://10.25.138.109/countries',
			  data: {get_param: 'value'},
			  dataType: 'json',
			  success: function (data) {
			  $.each(data, function(index, element) {
				$('#success').append($('<div>', {
					text: element.name
				}));
			  });
			  }
			});
			
			var data = [
			  { "name" : "Canada" },
			  { "name" : "New Zealand" }
			];

			var g = d3.select("svg").selectAll("g").data(data);
		
			var en = g.enter().append("g")
				.attr("transform",function(d){ 
				return "translate("+ (Math.random() * 100) + 40 + "," + (Math.random() * 100) + 40 +")" 
			});
			
			var circle = en.append("circle")
				.attr("r",function(d){ return Math.random() * 20 })
				.attr("fill",function(d,i){ return i % 2 == 0 ? "red" : "blue" });
			
			en.append("text").text(function(d){ return d.name });*/
					
				//});
			//}
		});
	
    </script>


</body>

</html>